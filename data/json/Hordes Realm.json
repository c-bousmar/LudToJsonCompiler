{
    "define": {
        "BoardSites": "(difference (sites Board) (sites Corners))",
        "MoverSites": "(sites Occupied by:Mover component:\"Disc\")",
        "CurrentDirection": "(directions Cell from:(var \"LF\") to:(var \"LT\"))",
        "OppositeDirection": "(directions Cell from:(var \"LT\") to:(var \"LF\"))",
        "MaxMoveDistanceBasedOn": "(+ (count Sites in:#1) (count Pieces of:(- 3 (mover)) in:#1 ))",
        "DestinationOf": "(ahead Cell #1 steps:(var \"Offset\") \"CurrentDirection\")",
        "MoveTheColumnForwardAt": "(seq { (set Var \"PiecesMoved\" 0) (set Var \"Offset\" (var \"LD\")) (remove (sites Direction from:#1 \"CurrentDirection\" included:True distance:(- (var \"LD\") 1) )) (while (> (var \"LD\") (var \"PiecesMoved\")) (if (is Empty (\"DestinationOf\" #1)) (add (to (\"DestinationOf\" #1)) (then (seq { (set Var \"Offset\" (+ 1 (var \"Offset\"))) (set Var \"PiecesMoved\" (+ 1 (var \"PiecesMoved\"))) } ))) (remove (\"DestinationOf\" #1) (then (set Var \"PiecesMoved\" (+ 1 (var \"PiecesMoved\")))) ))) } )",
        "SubsequentLT": "(ahead (from) steps:(var \"LD\") \"CurrentDirection\")",
        "OriginSites": "(sites (values Remembered \"Origins\"))",
        "SitesFromOrigins": "(sites Direction from:\"OriginSites\" #1 included:True distance:Infinity)",
        "SitesInMovedColumns": "(union (\"SitesFromOrigins\" \"CurrentDirection\") (\"SitesFromOrigins\" \"OppositeDirection\"))",
        "AdjacentSeedSites": "(difference (sites Around (sites (values Remembered \"Origins\"))) (\"SitesInMovedColumns\"))",
        "SitesFromSeeds": "(sites Direction from:\"AdjacentSeedSites\" #1 included:True distance:(- (var \"LD\") 1))",
        "SubsequentAvailableSites": "(sites Direction from:(\"SubsequentLT\") \"CurrentDirection\" included:True stop:(or (= (mover) (who at:(to))) (is In (to) (sites Corners)) ))",
        "IfAllowedSecondaryDestination": "(and { (is In (from) (union (\"SitesFromSeeds\" \"CurrentDirection\") (\"SitesFromSeeds\" \"OppositeDirection\") )) (not (is In (\"SubsequentLT\") (sites Corners))) (all Sites (sites Between from:(from) to:(\"SubsequentLT\")) if:(= (mover) (who at:(site)))) (!= (mover) (who at:(\"SubsequentLT\"))) (<= (var \"LD\") (\"MaxMoveDistanceBasedOn\" \"SubsequentAvailableSites\") ) } )",
        "SubsequentColumnAttack": "(move Select (from (\"MoverSites\") if:(\"IfAllowedSecondaryDestination\") ) (then (seq { (set Var \"ALF\" (last From)) (remember Value \"Origins\" (var \"ALF\") unique:True) (\"MoveTheColumnForwardAt\" (var \"ALF\")) } )))",
        "AvailableSites": "(sites Direction from:(to) (directions Cell from:(from) to:(to)) included:True stop:(or (= (mover) (who at:(to))) (is In (to) (sites Corners)) ))",
        "FirstColumnAttack": "(forEach Piece (do (set Var \"LF\" (from)) next:(move Select (from (from) if:(is In (from) (\"MoverSites\"))) (to (difference (difference (sites Direction from:(from) Adjacent) (sites Corners) ) (\"MoverSites\") ) if:(and { (all Sites (sites Between Adjacent Cell from:(from) to:(to)) if:(is In (site) (\"MoverSites\")) ) (<= (count Steps Adjacent (from) (to)) (\"MaxMoveDistanceBasedOn\" \"AvailableSites\") ) } ) ) (then (seq { (set Var \"LT\" (last To)) (remember Value \"Origins\" (var \"LF\") unique:True) (set Var \"LD\" (count Steps (var \"LF\") (var \"LT\"))) (\"MoveTheColumnForwardAt\" (var \"LF\")) (if (can Move (\"SubsequentColumnAttack\")) (moveAgain)) } )))))",
        "EmptyBoardSites": "(difference (sites Empty) (sites Corners))",
        "EnemySites": "(sites Occupied by:(player (- 3 (mover))))",
        "DirectionFromWhichToAdd": "(ahead (to) (directions Cell from:(var \"RD\") to:(centrePoint Cell)))",
        "ConnectivityRestriction": "(!= Infinity (count Steps Adjacent (step (to if:#1)) (to) (sites Around (var \"RD\") Orthogonal) ))",
        "ToPotentialReinforcementSites": "(to (difference (\"EmptyBoardSites\") (sites Around (\"EnemySites\")) ) if:(and { <Restricted:reinforcementSites> (= (id \"Disc\" Mover) (what at:(\"DirectionFromWhichToAdd\"))) } ))",
        "SelectedDirectionReinforcement": "(forEach Piece (move (from (intersection (sites Corners) (sites Occupied by:Mover component:\"Hex\"))) (to (sites Corners) if:(is Empty (to)) (apply (set Var \"RD\" <CornerOccupation:type>)) ) (then (add (\"ToPotentialReinforcementSites\")) )) Mover )",
        "AnyDirectionReinforcement": "(move Select (from (sites Corners)) (then (set Var \"RD\" (last To) (then (add (\"ToPotentialReinforcementSites\")) ))))",
        "Reinforce": "(do (if (no Pieces in:(sites Corners)) (\"AnyDirectionReinforcement\") (\"SelectedDirectionReinforcement\") ) ifAfterwards:(!= (value Player Mover) (count Pieces Mover)) )",
        "StandardTurn": "(if (\"NewTurn\") (do (seq { (forget Value All) (set Value Mover (count Pieces Mover)) (if (!= (var \"StalemateIn\") 0) (if (!= (value Player Prev) (count Pieces Prev)) (set Var \"StalemateIn\" 5) (set Var \"StalemateIn\" (- (var \"StalemateIn\") 1)) )) } ) next:(if (and (= (var \"StalemateIn\") 0) (!= (count Pieces \"Disc2\") (count Pieces \"Disc1\"))) (move Pass) (or (\"Reinforce\") (\"FirstColumnAttack\") ))) (or { <Passing:option> (and { (\"SubsequentColumnAttack\") } (then (if (can Move (\"SubsequentColumnAttack\")) (moveAgain)) )) } ))",
        "CornerStart": "(start { (place \"Hex1\" (sites Random (intersection (sites Empty) (sites Corners)) num:#1) ) (place \"Hex2\" (sites Random (intersection (sites Empty) (sites Corners)) num:#1) ) } )",
        "CenterStart": "(start { (place \"Disc2\" (centrePoint)) (set RememberValue #1) } )"
    },
    "game": "\"Hordes Realm\" (players 2) (equipment { <Variant:board> (piece \"Disc\" Each) (piece \"Hex\" Each) } ) (rules (<Setup:start> <CornerOccupation:start>) phases:{ <Setup:phase1> <Setup:phase2> (phase \"PlayPhase\" (play (\"StandardTurn\") ) (end { (if (no Pieces Next \"Disc\") (result Next Loss) ) (if (and (= (var \"StalemateIn\") 0) (> (count Pieces \"Disc1\") (count Pieces \"Disc2\")) ) (result P1 Win) ) (if (and (= (var \"StalemateIn\") 0) (> (count Pieces \"Disc2\") (count Pieces \"Disc1\")) ) (result P2 Win) ) } )) }",
    "option": {},
    "rulesets": {},
    "metadata": {}
}